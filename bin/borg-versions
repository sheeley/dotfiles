#! /usr/bin/env nu --stdin

def main [
	search_term: string # filename or content to search for
	--all_repos = false # search all, not just local
	--content = false # search file contents instead of filenames
] {
	let repo = if ($all_repos) { "" } else { "local" }
	let home_dir = ($env.HOME)
	
	print $"Searching for: ($search_term)"
	print $"Search type: (if ($content) { "content" } else { "filename" })"
	
	if ($content) {
		print "Content search not yet implemented - searching filenames instead"
	}
	
	print "Searching for files..."
	
	# Search filenames using borgmatic list --find with --short to get just paths
	let all_files = try {
		(^borgmatic list --repository $repo --find $search_term --short | complete).stdout
		| lines 
		| where ($it | str trim) != ""
		| where ($it | str contains "local:") == false
		| where ($it | str contains "Listing archive") == false
		| where ($it | str contains "Searching archives") == false
		| each { |file| $file | str trim }
	} catch {
		[]
	}
	
	if ($all_files | is-empty) {
		print $"No matches found for '($search_term)'"
		return
	}
	
	# Get unique filenames and replace home directory with ~
	let unique_files = ($all_files 
		| uniq 
		| each { |file|
			if ($file | str starts-with $home_dir) {
				$file | str replace $home_dir "~"
			} else if ($file | str starts-with "/Users/") {
				$file | str replace --regex "^/Users/[^/]+" "~"
			} else {
				$file
			}
		}
		| sort)
	
	print $"\nFound ($unique_files | length) unique files"
	
	# First selection: choose which file
	let selected_file_display = ($unique_files | input list --fuzzy $"Select file to see versions:")
	
	if ($selected_file_display | is-empty) {
		print "No file selected"
		return
	}
	
	# Convert back to full path for matching
	let selected_file_full = if ($selected_file_display | str starts-with "~") {
		$selected_file_display | str replace "~" $home_dir
	} else {
		$selected_file_display
	}
	
	print $"\nGetting versions for ($selected_file_display)..."
	
	# Get all archives that contain this specific file - suppress verbose output
	let archives_with_file = try {
		(^borgmatic list --repository $repo --short --last 20 | complete).stdout
		| lines 
		| where ($it | str trim) != ""
		| where ($it | str contains "local:") == false
		| where ($it | str contains "Listing archive") == false
		| each { |archive|
			let archive_name = ($archive | str trim)
			# Check if this archive contains the file (suppress output)
			let has_file = try {
				let result = (^borgmatic list --repository $repo --archive $archive_name --path $selected_file_full --short | complete)
				if ($result.exit_code == 0 and ($result.stdout | str trim) != "") {
					1
				} else {
					0
				}
			} catch { 0 }
			
			if ($has_file > 0) {
				$archive_name
			}
		}
		| where ($it != null)
		| sort -r
	} catch {
		[]
	}
	
	if ($archives_with_file | is-empty) {
		print $"No versions found for ($selected_file_display)"
		return
	}
	
	print $"\nFound ($archives_with_file | length) versions of ($selected_file_display)"
	print "Use j/k or ↑/↓ to navigate, Enter to restore, q to quit"
	
	# Interactive selection with preview
	let selected_archive = (interactive_select_with_preview $archives_with_file $selected_file_full $selected_file_display $repo)
	
	if ($selected_archive | is-empty) {
		print "No version selected"
		return
	}
	
	let selected_file = $selected_file_full
	
	print $"\nRestoring ($selected_file_display) from ($selected_archive)..."
	
	# Restore file
	try {
		# Create a unique temp directory to avoid conflicts
		let temp_dir = $"/tmp/borg-restore-(date now | format date '%Y%m%d-%H%M%S')"
		mkdir $temp_dir
		
		# Extract file to temp location
		^borgmatic extract --repository $repo --archive $selected_archive --destination $temp_dir --path $selected_file | complete
		let temp_file = $"($temp_dir)/($selected_file)"
		
		if ($temp_file | path exists) {
			# Backup current file if it exists
			if ($selected_file | path exists) {
				cp $selected_file $"($selected_file).bak"
				print $"Backed up current file to ($selected_file).bak"
			}
			
			# Create directory if it doesn't exist
			let parent_dir = ($selected_file | path dirname)
			if not ($parent_dir | path exists) {
				mkdir $parent_dir
			}
			
			# Restore file
			cp $temp_file $selected_file
			print $"Restored ($selected_file) from archive ($selected_archive)"
			
			# Clean up temp directory
			rm -rf $temp_dir
		} else {
			print "Could not extract file for restoration"
			rm -rf $temp_dir
		}
	} catch { |e|
		print $"Error during restoration: ($e)"
	}
}

def interactive_select_with_preview [archives: list<string>, file_path: string, display_path: string, repo: string] {
	let total = ($archives | length)
	mut current_index = 0
	
	loop {
		# Clear screen and show interface
		^clear
		
		# Header
		print $"File: ($display_path)"
		print $"Use j/k or ↑/↓ to navigate, Enter to restore, q to quit"
		print "═══════════════════════════════════════════════════════════════════════════════"
		
		# Get terminal width for layout (assume 80 chars if can't detect)
		let term_width = try { 
			(^tput cols | into int) 
		} catch { 
			80 
		}
		let left_width = ($term_width / 2 - 2)
		let right_width = ($term_width / 2 - 2)
		
		# Show current archive and preview side by side
		let current_archive = ($archives | get $current_index)
		
		# Get preview content first
		let preview_content = try {
			let temp_dir = $"/tmp/borg-preview-(date now | format date '%Y%m%d-%H%M%S')"
			mkdir $temp_dir
			
			let extract_result = (^borgmatic extract --repository $repo --archive $current_archive --destination $temp_dir --path $file_path | complete)
			
			if ($extract_result.exit_code == 0) {
				let temp_file = $"($temp_dir)/($file_path)"
				if ($temp_file | path exists) {
					let content = (cat $temp_file | lines | first 30)
					rm -rf $temp_dir
					$content
				} else {
					rm -rf $temp_dir
					["File not found in archive"]
				}
			} else {
				rm -rf $temp_dir
				["Error extracting file"]
			}
		} catch {
			["Error previewing file"]
		}
		
		# Show archives list on left, preview on right
		print $"Archives (($current_index + 1)/($total))                    │ Preview from ($current_archive)"
		print "─────────────────────────────────────────────────────────────┼─────────────────────────────────────────────────────────────"
		
		# Calculate how many archive lines to show
		let max_lines = 25
		let start_idx = if ($current_index >= $max_lines) { $current_index - $max_lines + 1 } else { 0 }
		let end_idx = if ($start_idx + $max_lines > $total) { $total } else { $start_idx + $max_lines }
		
		for $line_num in 0..($max_lines - 1) {
			let archive_line = if ($line_num < ($preview_content | length)) {
				if ($start_idx + $line_num < $end_idx) {
					let archive_idx = $start_idx + $line_num
					let archive = ($archives | get $archive_idx)
					let prefix = if ($archive_idx == $current_index) { "► " } else { "  " }
					let truncated = if (($archive | str length) > ($left_width - 3)) { 
						($archive | str substring 0..($left_width - 6)) + "..." 
					} else { 
						$archive 
					}
					$"($prefix)($truncated)"
				} else {
					""
				}
			} else {
				""
			}
			
			let preview_line = if ($line_num < ($preview_content | length)) {
				let line = ($preview_content | get $line_num)
				if (($line | str length) > $right_width) {
					($line | str substring 0..($right_width - 3)) + "..."
				} else {
					$line
				}
			} else {
				""
			}
			
			# Pad archive line to left width
			let padded_archive = $archive_line + (0..($left_width - ($archive_line | str length)) | each { " " } | str join "")
			print $"($padded_archive)│ ($preview_line)"
		}
		
		# Get single character input
		print -n "Command: "
		let input_char = (input --numchar 1)
		
		# Handle navigation
		if ($input_char == "k" or $input_char == "A") {  # k or up arrow
			if ($current_index > 0) {
				$current_index = ($current_index - 1)
			}
		} else if ($input_char == "j" or $input_char == "B") {  # j or down arrow
			if ($current_index < ($total - 1)) {
				$current_index = ($current_index + 1)
			}
		} else if ($input_char == "\r" or $input_char == "\n") {  # Enter
			return ($archives | get $current_index)
		} else if ($input_char == "q") {  # q to quit
			return ""
		}
	}
}
