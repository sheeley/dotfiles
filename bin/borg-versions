#! /usr/bin/env -S uv run --script
# /// script
# dependencies = [
# ]
# ///

"""
Interactive file search, preview, and restore tool for Borg backups via borgmatic.
"""

import asyncio
import os
import shutil
import subprocess
import tempfile
from pathlib import Path
from typing import List, Optional

from textual.app import App, ComposeResult
from textual.containers import Container, Horizontal, Vertical
from textual.widgets import (
    Button,
    Footer,
    Header,
    Input,
    Label,
    ListItem,
    ListView,
    Static,
    TextArea,
)
from textual.binding import Binding
from textual.message import Message


class FileSearchApp(App):
    """Main application for searching and restoring files from Borg archives."""
    
    CSS = """
    .search-container {
        height: 3;
        margin: 1;
    }
    
    .main-container {
        height: 1fr;
    }
    
    .file-list {
        width: 1fr;
        border: solid $primary;
        margin-right: 1;
    }
    
    .archive-list {
        width: 1fr;
        border: solid $primary;
        margin-right: 1;
    }
    
    .preview-area {
        width: 2fr;
        border: solid $primary;
    }
    
    .status-bar {
        height: 3;
        background: $surface;
        margin: 1;
    }
    """
    
    BINDINGS = [
        Binding("ctrl+c", "quit", "Quit"),
        Binding("ctrl+q", "quit", "Quit"),
        Binding("escape", "back", "Back"),
        Binding("enter", "select", "Select/Restore"),
    ]
    
    def __init__(self, search_term: str, all_repos: bool = False, content: bool = False):
        super().__init__()
        self.search_term = search_term
        self.repo = "" if all_repos else "local"
        self.content_search = content
        self.home_dir = os.path.expanduser("~")
        
        # State management
        self.current_mode = "search"  # search, files, archives
        self.found_files: List[str] = []
        self.selected_file_display = ""
        self.selected_file_full = ""
        self.archives_with_file: List[str] = []
        self.current_preview = ""
    
    def compose(self) -> ComposeResult:
        """Create the UI layout."""
        yield Header()
        
        with Container(classes="search-container"):
            yield Label(f"Searching for: {self.search_term}")
            yield Label(f"Search type: {'content' if self.content_search else 'filename'}")
        
        with Horizontal(classes="main-container"):
            with Vertical(classes="file-list"):
                yield Label("Files", id="files-label")
                yield ListView(id="files-listview")
            
            with Vertical(classes="archive-list"):
                yield Label("Archives", id="archives-label")
                yield ListView(id="archives-listview")
            
            with Vertical(classes="preview-area"):
                yield Label("Preview", id="preview-label")
                yield TextArea("", read_only=True, id="preview-text")
        
        with Container(classes="status-bar"):
            yield Label("Searching for files...", id="status")
        
        yield Footer()
    
    async def on_mount(self) -> None:
        """Initialize the application by searching for files."""
        await self.search_files()
    
    async def search_files(self) -> None:
        """Search for files matching the search term."""
        status = self.query_one("#status", Label)
        status.update("Searching for files...")
        
        try:
            # Run borgmatic search
            cmd = [
                "borgmatic", "list", 
                "--repository", self.repo,
                "--find", self.search_term,
                "--short"
            ]
            
            result = subprocess.run(
                cmd, 
                capture_output=True, 
                text=True, 
                check=False
            )
            
            if result.returncode != 0:
                status.update(f"Error searching: {result.stderr}")
                return
            
            # Parse results and filter out verbose output
            all_files = []
            for line in result.stdout.splitlines():
                line = line.strip()
                if (line and 
                    "local:" not in line and 
                    "Listing archive" not in line and 
                    "Searching archives" not in line):
                    all_files.append(line)
            
            if not all_files:
                status.update(f"No matches found for '{self.search_term}'")
                return
            
            # Get unique files and replace home directory with ~
            unique_files = []
            seen = set()
            for file_path in all_files:
                if file_path not in seen:
                    seen.add(file_path)
                    display_path = self.format_display_path(file_path)
                    unique_files.append((display_path, file_path))
            
            unique_files.sort(key=lambda x: x[0])
            self.found_files = unique_files
            
            # Update UI
            await self.update_files_list()
            status.update(f"Found {len(unique_files)} unique files")
            
        except Exception as e:
            status.update(f"Error during search: {str(e)}")
    
    def format_display_path(self, file_path: str) -> str:
        """Format file path for display, replacing home directory with ~."""
        if file_path.startswith(self.home_dir):
            return file_path.replace(self.home_dir, "~", 1)
        elif file_path.startswith("/Users/"):
            # Handle other user directories
            parts = file_path.split("/")
            if len(parts) >= 3:
                return "~" + "/" + "/".join(parts[3:])
        return file_path
    
    async def update_files_list(self) -> None:
        """Update the files list view."""
        files_listview = self.query_one("#files-listview", ListView)
        files_listview.clear()
        
        for display_path, _ in self.found_files:
            files_listview.append(ListItem(Label(display_path)))
    
    async def on_list_view_selected(self, event: ListView.Selected) -> None:
        """Handle selection in list views."""
        if event.list_view.id == "files-listview":
            await self.handle_file_selection(event.item.children[0].renderable)
        elif event.list_view.id == "archives-listview":
            await self.handle_archive_selection(event.item.children[0].renderable)
    
    async def handle_file_selection(self, selected_label: str) -> None:
        """Handle file selection and find archives containing it."""
        self.selected_file_display = selected_label
        
        # Find the full path
        for display_path, full_path in self.found_files:
            if display_path == selected_label:
                self.selected_file_full = full_path
                break
        
        # Convert back to full path if needed
        if self.selected_file_display.startswith("~"):
            self.selected_file_full = self.selected_file_display.replace("~", self.home_dir, 1)
        
        status = self.query_one("#status", Label)
        status.update(f"Getting versions for {self.selected_file_display}...")
        
        await self.find_archives_with_file()
    
    async def find_archives_with_file(self) -> None:
        """Find all archives that contain the selected file."""
        try:
            # Get list of recent archives
            cmd = ["borgmatic", "list", "--repository", self.repo, "--short", "--last", "20"]
            result = subprocess.run(cmd, capture_output=True, text=True, check=False)
            
            if result.returncode != 0:
                self.query_one("#status", Label).update(f"Error getting archives: {result.stderr}")
                return
            
            archives = []
            for line in result.stdout.splitlines():
                line = line.strip()
                if line and "local:" not in line and "Listing archive" not in line:
                    archives.append(line)
            
            # Check which archives contain the file
            archives_with_file = []
            for archive in archives:
                if await self.archive_contains_file(archive, self.selected_file_full):
                    archives_with_file.append(archive)
            
            archives_with_file.sort(reverse=True)  # Most recent first
            self.archives_with_file = archives_with_file
            
            if not archives_with_file:
                self.query_one("#status", Label).update(f"No versions found for {self.selected_file_display}")
                return
            
            await self.update_archives_list()
            self.query_one("#status", Label).update(
                f"Found {len(archives_with_file)} versions of {self.selected_file_display}"
            )
            
        except Exception as e:
            self.query_one("#status", Label).update(f"Error finding archives: {str(e)}")
    
    async def archive_contains_file(self, archive: str, file_path: str) -> bool:
        """Check if an archive contains the specified file."""
        try:
            cmd = [
                "borgmatic", "list",
                "--repository", self.repo,
                "--archive", archive,
                "--path", file_path,
                "--short"
            ]
            result = subprocess.run(cmd, capture_output=True, text=True, check=False)
            return result.returncode == 0 and result.stdout.strip()
        except:
            return False
    
    async def update_archives_list(self) -> None:
        """Update the archives list view."""
        archives_listview = self.query_one("#archives-listview", ListView)
        archives_listview.clear()
        
        for archive in self.archives_with_file:
            archives_listview.append(ListItem(Label(archive)))
    
    async def handle_archive_selection(self, selected_archive: str) -> None:
        """Handle archive selection and show preview."""
        await self.show_preview(selected_archive)
    
    async def show_preview(self, archive: str) -> None:
        """Extract and show preview of the file from the selected archive."""
        preview_text = self.query_one("#preview-text", TextArea)
        preview_label = self.query_one("#preview-label", Label)
        
        preview_label.update(f"Preview from {archive}")
        preview_text.text = "Loading preview..."
        
        try:
            with tempfile.TemporaryDirectory(prefix="borg-preview-") as temp_dir:
                # Extract file
                cmd = [
                    "borgmatic", "extract",
                    "--repository", self.repo,
                    "--archive", archive,
                    "--destination", temp_dir,
                    "--path", self.selected_file_full
                ]
                
                result = subprocess.run(cmd, capture_output=True, text=True, check=False)
                
                if result.returncode == 0:
                    temp_file = Path(temp_dir) / self.selected_file_full.lstrip("/")
                    if temp_file.exists():
                        try:
                            with open(temp_file, 'r', encoding='utf-8') as f:
                                content = f.read()
                                # Limit preview to first 1000 lines
                                lines = content.splitlines()
                                if len(lines) > 1000:
                                    content = "\n".join(lines[:1000]) + f"\n\n... (truncated, showing first 1000 of {len(lines)} lines)"
                                preview_text.text = content
                        except UnicodeDecodeError:
                            preview_text.text = "Binary file - cannot preview"
                        except Exception as e:
                            preview_text.text = f"Error reading file: {str(e)}"
                    else:
                        preview_text.text = "File not found in archive"
                else:
                    preview_text.text = f"Error extracting file: {result.stderr}"
                    
        except Exception as e:
            preview_text.text = f"Error during preview: {str(e)}"
    
    async def action_select(self) -> None:
        """Handle Enter key - restore the currently selected file."""
        archives_listview = self.query_one("#archives-listview", ListView)
        
        if archives_listview.highlighted_child:
            selected_archive = archives_listview.highlighted_child.children[0].renderable
            await self.restore_file(selected_archive)
    
    async def restore_file(self, archive: str) -> None:
        """Restore the selected file from the specified archive."""
        status = self.query_one("#status", Label)
        status.update(f"Restoring {self.selected_file_display} from {archive}...")
        
        try:
            with tempfile.TemporaryDirectory(prefix="borg-restore-") as temp_dir:
                # Extract file
                cmd = [
                    "borgmatic", "extract",
                    "--repository", self.repo,
                    "--archive", archive,
                    "--destination", temp_dir,
                    "--path", self.selected_file_full
                ]
                
                result = subprocess.run(cmd, capture_output=True, text=True, check=False)
                
                if result.returncode == 0:
                    temp_file = Path(temp_dir) / self.selected_file_full.lstrip("/")
                    if temp_file.exists():
                        # Backup current file if it exists
                        target_file = Path(self.selected_file_full)
                        if target_file.exists():
                            backup_file = f"{target_file}.bak"
                            shutil.copy2(target_file, backup_file)
                            status.update(f"Backed up current file to {backup_file}")
                        
                        # Create directory if needed
                        target_file.parent.mkdir(parents=True, exist_ok=True)
                        
                        # Restore file
                        shutil.copy2(temp_file, target_file)
                        status.update(f"Restored {self.selected_file_display} from {archive}")
                    else:
                        status.update("File not found in extracted archive")
                else:
                    status.update(f"Error extracting file: {result.stderr}")
                    
        except Exception as e:
            status.update(f"Error during restoration: {str(e)}")
    
    async def action_back(self) -> None:
        """Handle Escape key - go back to previous view."""
        # Clear current selections and return to file list
        archives_listview = self.query_one("#archives-listview", ListView)
        archives_listview.clear()
        
        preview_text = self.query_one("#preview-text", TextArea)
        preview_text.text = ""
        
        preview_label = self.query_one("#preview-label", Label)
        preview_label.update("Preview")
        
        status = self.query_one("#status", Label)
        status.update(f"Found {len(self.found_files)} unique files")


def main():
    """Main entry point."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Interactive file search and restore for Borg backups")
    parser.add_argument("search_term", help="Filename or content to search for")
    parser.add_argument("--all-repos", action="store_true", help="Search all repositories, not just local")
    parser.add_argument("--content", action="store_true", help="Search file contents instead of filenames")
    
    args =.parse_args()
    
    if args.content:
        print("Content search not yet implemented - searching filenames instead")
    
    app = FileSearchApp(args.search_term, args.all_repos, args.content)
    app.run()


if __name__ == "__main__":
    main()
