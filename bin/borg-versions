#! /usr/bin/env -S uv run --script
# /// script
# dependencies = [
#     "textual",
# ]
# ///

"""
Interactive file search, preview, and restore tool for Borg backups via borgmatic.
"""

import argparse
import asyncio
import os
import shutil
import subprocess
import tempfile
from pathlib import Path
from typing import Dict, List, Tuple

from textual.app import App, ComposeResult
from textual.containers import Container, Horizontal, Vertical
from textual.widgets import (
    Footer,
    Header,
    Label,
    ListItem,
    ListView,
    TextArea,
)
from textual.binding import Binding


class FileSearchApp(App):
    """Main application for searching and restoring files from Borg archives."""
    
    CSS = """
    .search-container {
        height: 3;
        margin: 1;
    }
    
    .main-container {
        height: 1fr;
    }
    
    .file-list {
        width: 1fr;
        border: solid $primary;
        margin-right: 1;
    }
    
    .archive-list {
        width: 1fr;
        border: solid $primary;
        margin-right: 1;
    }
    
    .preview-area {
        width: 2fr;
        border: solid $primary;
    }
    
    .status-bar {
        height: 3;
        background: $surface;
        margin: 1;
    }
    
    .activity {
        color: $warning;
    }
    """
    
    BINDINGS = [
        Binding("ctrl+c", "quit", "Quit"),
        Binding("ctrl+q", "quit", "Quit"),
        Binding("escape", "back", "Back"),
        Binding("enter", "select", "Select/Restore"),
    ]
    
    def __init__(self, search_term: str, all_repos: bool = False, content: bool = False):
        super().__init__()
        self.search_term = search_term
        self.repo = "" if all_repos else "local"
        self.content_search = content
        self.home_dir = os.path.expanduser("~")
        
        # State management
        self.found_files: List[Tuple[str, str]] = []
        self.selected_file_display = ""
        self.selected_file_full = ""
        self.archives_with_file: List[str] = []
        
        # Cache for file -> archives mapping
        self.file_archives_cache: Dict[str, List[str]] = {}
        
        # Activity indicator state
        self.activity_task = None
    
    def compose(self) -> ComposeResult:
        """Create the UI layout."""
        yield Header()
        
        with Container(classes="search-container"):
            yield Label(f"Searching for: {self.search_term}")
            yield Label(f"Search type: {'content' if self.content_search else 'filename'}")
        
        with Horizontal(classes="main-container"):
            with Vertical(classes="file-list"):
                yield Label("Files", id="files-label")
                yield ListView(id="files-listview")
            
            with Vertical(classes="archive-list"):
                yield Label("Archives", id="archives-label")
                yield ListView(id="archives-listview")
            
            with Vertical(classes="preview-area"):
                yield Label("Preview", id="preview-label")
                yield TextArea("", read_only=True, id="preview-text")
        
        with Container(classes="status-bar"):
            yield Label("Searching for files...", id="status", classes="activity")
        
        yield Footer()
    
    async def start_activity_indicator(self, base_message: str) -> None:
        """Start an animated activity indicator."""
        if self.activity_task:
            self.activity_task.cancel()
        
        self.activity_task = asyncio.create_task(self._animate_activity(base_message))
    
    async def stop_activity_indicator(self) -> None:
        """Stop the activity indicator."""
        if self.activity_task:
            self.activity_task.cancel()
            self.activity_task = None
    
    async def _animate_activity(self, base_message: str) -> None:
        """Animate the activity indicator with rotating dots."""
        status = self.query_one("#status", Label)
        dots = ["⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"]
        i = 0
        
        try:
            while True:
                status.update(f"{dots[i]} {base_message}")
                status.add_class("activity")
                i = (i + 1) % len(dots)
                await asyncio.sleep(0.1)
        except asyncio.CancelledError:
            pass
    
    async def update_status(self, message: str, is_final: bool = True) -> None:
        """Update status message and optionally stop activity indicator."""
        if is_final:
            await self.stop_activity_indicator()
        
        status = self.query_one("#status", Label)
        status.update(message)
        if is_final:
            status.remove_class("activity")
    
    async def on_mount(self) -> None:
        """Initialize the application by searching for files."""
        await self.search_files()
    
    async def search_files(self) -> None:
        """Search for files matching the search term."""
        await self.start_activity_indicator("Searching for files...")
        
        try:
            # Run borgmatic search
            cmd = [
                "borgmatic", "list", 
                "--repository", self.repo,
                "--find", self.search_term,
                "--short"
            ]
            
            result = subprocess.run(
                cmd, 
                capture_output=True, 
                text=True, 
                check=False
            )
            
            if result.returncode != 0:
                await self.update_status(f"❌ Error searching: {result.stderr}")
                return
            
            # Parse results and filter out verbose output
            all_files = []
            for line in result.stdout.splitlines():
                line = line.strip()
                if (line and 
                    "local:" not in line and 
                    "Listing archive" not in line and 
                    "Searching archives" not in line):
                    all_files.append(line)
            
            if not all_files:
                await self.update_status(f"❌ No matches found for '{self.search_term}'")
                return
            
            # Get unique files and replace home directory with ~
            unique_files = []
            seen = set()
            for file_path in all_files:
                if file_path not in seen:
                    seen.add(file_path)
                    display_path = self.format_display_path(file_path)
                    unique_files.append((display_path, file_path))
            
            unique_files.sort(key=lambda x: x[0])
            self.found_files = unique_files
            
            # Update UI
            await self.update_files_list()
            await self.update_status(f"✅ Found {len(unique_files)} unique files")
            
        except Exception as e:
            await self.update_status(f"❌ Error during search: {str(e)}")
    
    def format_display_path(self, file_path: str) -> str:
        """Format file path for display, replacing home directory with ~."""
        if file_path.startswith(self.home_dir):
            return file_path.replace(self.home_dir, "~", 1)
        elif file_path.startswith("/Users/"):
            # Handle other user directories
            parts = file_path.split("/")
            if len(parts) >= 3:
                return "~" + "/" + "/".join(parts[3:])
        return file_path
    
    async def update_files_list(self) -> None:
        """Update the files list view."""
        files_listview = self.query_one("#files-listview", ListView)
        files_listview.clear()
        
        for display_path, _ in self.found_files:
            files_listview.append(ListItem(Label(display_path)))
    
    async def on_list_view_selected(self, event: ListView.Selected) -> None:
        """Handle selection in list views."""
        if event.list_view.id == "files-listview":
            await self.handle_file_selection(event.item.children[0].renderable)
        elif event.list_view.id == "archives-listview":
            await self.handle_archive_selection(event.item.children[0].renderable)
    
    async def on_list_view_highlighted(self, event: ListView.Highlighted) -> None:
        """Handle highlighting in list views."""
        if event.list_view.id == "archives-listview" and event.item:
            # Update preview when archive is highlighted
            archive_name = event.item.children[0].renderable
            await self.show_preview(archive_name)
    
    async def handle_file_selection(self, selected_label: str) -> None:
        """Handle file selection and find archives containing it."""
        self.selected_file_display = selected_label
        
        # Find the full path
        for display_path, full_path in self.found_files:
            if display_path == selected_label:
                self.selected_file_full = full_path
                break
        
        # Convert back to full path if needed
        if self.selected_file_display.startswith("~"):
            self.selected_file_full = self.selected_file_display.replace("~", self.home_dir, 1)
        
        await self.find_archives_with_file()
    
    async def find_archives_with_file(self) -> None:
        """Find all archives that contain the selected file."""
        # Check cache first
        if self.selected_file_full in self.file_archives_cache:
            self.archives_with_file = self.file_archives_cache[self.selected_file_full]
            await self.update_archives_list()
            await self.update_status(
                f"✅ Found {len(self.archives_with_file)} versions of {self.selected_file_display} (cached)"
            )
            return
        
        await self.start_activity_indicator(f"Getting versions for {self.selected_file_display}...")
        
        try:
            # Get list of recent archives
            cmd = ["borgmatic", "list", "--repository", self.repo, "--short", "--last", "20"]
            result = subprocess.run(cmd, capture_output=True, text=True, check=False)
            
            if result.returncode != 0:
                await self.update_status(f"❌ Error getting archives: {result.stderr}")
                return
            
            archives = []
            for line in result.stdout.splitlines():
                line = line.strip()
                if line and "local:" not in line and "Listing archive" not in line:
                    archives.append(line)
            
            # Check which archives contain the file
            archives_with_file = []
            for i, archive in enumerate(archives):
                await self.start_activity_indicator(f"Checking archive {i+1}/{len(archives)}: {archive[:30]}...")
                if await self.archive_contains_file(archive, self.selected_file_full):
                    archives_with_file.append(archive)
            
            archives_with_file.sort(reverse=True)  # Most recent first
            self.archives_with_file = archives_with_file
            
            # Cache the result
            self.file_archives_cache[self.selected_file_full] = archives_with_file
            
            if not archives_with_file:
                await self.update_status(f"❌ No versions found for {self.selected_file_display}")
                return
            
            await self.update_archives_list()
            await self.update_status(
                f"✅ Found {len(archives_with_file)} versions of {self.selected_file_display}"
            )
            
        except Exception as e:
            await self.update_status(f"❌ Error finding archives: {str(e)}")
    
    async def archive_contains_file(self, archive: str, file_path: str) -> bool:
        """Check if an archive contains the specified file."""
        try:
            cmd = [
                "borgmatic", "list",
                "--repository", self.repo,
                "--archive", archive,
                "--path", file_path,
                "--short"
            ]
            result = subprocess.run(cmd, capture_output=True, text=True, check=False)
            return result.returncode == 0 and result.stdout.strip()
        except:
            return False
    
    async def update_archives_list(self) -> None:
        """Update the archives list view."""
        archives_listview = self.query_one("#archives-listview", ListView)
        archives_listview.clear()
        
        for archive in self.archives_with_file:
            archives_listview.append(ListItem(Label(archive)))
    
    async def handle_archive_selection(self, selected_archive: str) -> None:
        """Handle archive selection and show preview."""
        await self.show_preview(selected_archive)
    
    async def show_preview(self, archive: str) -> None:
        """Extract and show preview of the file from the selected archive."""
        preview_text = self.query_one("#preview-text", TextArea)
        preview_label = self.query_one("#preview-label", Label)
        
        preview_label.update(f"Preview from {archive}")
        preview_text.text = "📄 Loading preview..."
        
        await self.start_activity_indicator(f"Extracting preview from {archive[:30]}...")
        
        try:
            with tempfile.TemporaryDirectory(prefix="borg-preview-") as temp_dir:
                # Extract file
                cmd = [
                    "borgmatic", "extract",
                    "--repository", self.repo,
                    "--archive", archive,
                    "--destination", temp_dir,
                    "--path", self.selected_file_full
                ]
                
                result = subprocess.run(cmd, capture_output=True, text=True, check=False)
                
                if result.returncode == 0:
                    temp_file = Path(temp_dir) / self.selected_file_full.lstrip("/")
                    if temp_file.exists():
                        try:
                            with open(temp_file, 'r', encoding='utf-8') as f:
                                content = f.read()
                                # Limit preview to first 1000 lines
                                lines = content.splitlines()
                                if len(lines) > 1000:
                                    content = "\n".join(lines[:1000]) + f"\n\n... (truncated, showing first 1000 of {len(lines)} lines)"
                                preview_text.text = content
                                await self.update_status(f"✅ Preview loaded from {archive}")
                        except UnicodeDecodeError:
                            preview_text.text = "📁 Binary file - cannot preview"
                            await self.update_status(f"ℹ️ Binary file detected in {archive}")
                        except Exception as e:
                            preview_text.text = f"❌ Error reading file: {str(e)}"
                            await self.update_status(f"❌ Error reading file from {archive}")
                    else:
                        preview_text.text = "❌ File not found in archive"
                        await self.update_status(f"❌ File not found in {archive}")
                else:
                    preview_text.text = f"❌ Error extracting file: {result.stderr}"
                    await self.update_status(f"❌ Error extracting from {archive}")
                    
        except Exception as e:
            preview_text.text = f"❌ Error during preview: {str(e)}"
            await self.update_status(f"❌ Error during preview: {str(e)}")
    
    async def action_select(self) -> None:
        """Handle Enter key - restore the currently selected file."""
        archives_listview = self.query_one("#archives-listview", ListView)
        
        if archives_listview.highlighted_child:
            selected_archive = archives_listview.highlighted_child.children[0].renderable
            await self.restore_file(selected_archive)
    
    async def restore_file(self, archive: str) -> None:
        """Restore the selected file from the specified archive."""
        await self.start_activity_indicator(f"Restoring {self.selected_file_display} from {archive[:30]}...")
        
        try:
            with tempfile.TemporaryDirectory(prefix="borg-restore-") as temp_dir:
                # Extract file
                cmd = [
                    "borgmatic", "extract",
                    "--repository", self.repo,
                    "--archive", archive,
                    "--destination", temp_dir,
                    "--path", self.selected_file_full
                ]
                
                result = subprocess.run(cmd, capture_output=True, text=True, check=False)
                
                if result.returncode == 0:
                    temp_file = Path(temp_dir) / self.selected_file_full.lstrip("/")
                    if temp_file.exists():
                        # Backup current file if it exists
                        target_file = Path(self.selected_file_full)
                        if target_file.exists():
                            backup_file = f"{target_file}.bak"
                            shutil.copy2(target_file, backup_file)
                            await self.update_status(f"💾 Backed up current file to {backup_file}", False)
                            await asyncio.sleep(1)  # Brief pause to show backup message
                        
                        # Create directory if needed
                        target_file.parent.mkdir(parents=True, exist_ok=True)
                        
                        # Restore file
                        shutil.copy2(temp_file, target_file)
                        await self.update_status(f"✅ Restored {self.selected_file_display} from {archive}")
                    else:
                        await self.update_status("❌ File not found in extracted archive")
                else:
                    await self.update_status(f"❌ Error extracting file: {result.stderr}")
                    
        except Exception as e:
            await self.update_status(f"❌ Error during restoration: {str(e)}")
    
    async def action_back(self) -> None:
        """Handle Escape key - go back to previous view."""
        # Stop any ongoing activity
        await self.stop_activity_indicator()
        
        # Clear current selections and return to file list
        archives_listview = self.query_one("#archives-listview", ListView)
        archives_listview.clear()
        
        preview_text = self.query_one("#preview-text", TextArea)
        preview_text.text = ""
        
        preview_label = self.query_one("#preview-label", Label)
        preview_label.update("Preview")
        
        await self.update_status(f"✅ Found {len(self.found_files)} unique files")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Interactive file search and restore for Borg backups")
    parser.add_argument("search_term", help="Filename or content to search for")
    parser.add_argument("--all-repos", action="store_true", help="Search all repositories, not just local")
    parser.add_argument("--content", action="store_true", help="Search file contents instead of filenames")
    
    args = parser.parse_args()
    
    if args.content:
        print("Content search not yet implemented - searching filenames instead")
    
    app = FileSearchApp(args.search_term, args.all_repos, args.content)
    app.run()


if __name__ == "__main__":
    main()
