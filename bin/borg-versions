#! /usr/bin/env nu --stdin

def main [
	search_term: string # filename or content to search for
	--all_repos = false # search all, not just local
	--content = false # search file contents instead of filenames
] {
	let repo = if ($all_repos) { "" } else { "local" }
	let home_dir = ($env.HOME)
	
	print $"Searching for: ($search_term)"
	print $"Search type: (if ($content) { "content" } else { "filename" })"
	
	if ($content) {
		print "Content search not yet implemented - searching filenames instead"
	}
	
	print "Searching for files..."
	
	# Search filenames using borgmatic list --find with --short to get just paths
	let all_files = try {
		^borgmatic list --repository $repo --find $search_term --short err>/dev/null
		| lines 
		| where ($it | str trim) != ""
		| where ($it | str contains "local:") == false
		| where ($it | str contains "Listing archive") == false
		| where ($it | str contains "Searching archives") == false
		| each { |file| $file | str trim }
	} catch {
		[]
	}
	
	if ($all_files | is-empty) {
		print $"No matches found for '($search_term)'"
		return
	}
	
	# Get unique filenames and replace home directory with ~
	let unique_files = ($all_files 
		| uniq 
		| each { |file|
			$file | str replace $home_dir "~"
		}
		| sort)
	
	print $"\nFound ($unique_files | length) unique files"
	
	# First selection: choose which file
	let selected_file_display = ($unique_files | input list --fuzzy $"Select file to see versions:")
	
	if ($selected_file_display | is-empty) {
		print "No file selected"
		return
	}
	
	# Convert back to full path for matching
	let selected_file_full = if ($selected_file_display | str starts-with "~") {
		$selected_file_display | str replace "~" $home_dir
	} else {
		$selected_file_display
	}
	
	print $"\nGetting versions for ($selected_file_display)..."
	
	# Get all archives that contain this specific file - suppress verbose output
	let archives_with_file = try {
		^borgmatic list --repository $repo --short --last 20 err>/dev/null
		| lines 
		| where ($it | str trim) != ""
		| where ($it | str contains "local:") == false
		| where ($it | str contains "Listing archive") == false
		| each { |archive|
			let archive_name = ($archive | str trim)
			# Check if this archive contains the file (suppress output)
			let has_file = try {
				let result = (^borgmatic list --repository $repo --archive $archive_name --path $selected_file_full --short err>/dev/null | complete)
				if ($result.exit_code == 0 and ($result.stdout | str trim) != "") {
					1
				} else {
					0
				}
			} catch { 0 }
			
			if ($has_file > 0) {
				$archive_name
			}
		}
		| where ($it != null)
		| sort -r
	} catch {
		[]
	}
	
	if ($archives_with_file | is-empty) {
		print $"No versions found for ($selected_file_display)"
		return
	}
	
	print $"\nFound ($archives_with_file | length) versions of ($selected_file_display)"
	
	# Second selection: choose which version
	let selected_archive = ($archives_with_file | input list --fuzzy $"Select version to preview/restore:")
	
	if ($selected_archive | is-empty) {
		print "No version selected"
		return
	}
	
	let selected_file = $selected_file_full
	
	print $"\nSelected: ($selected_file_display) from ($selected_archive)"
	
	# Preview file
	print "\n--- File Preview ---"
	try {
		# Create a unique temp directory to avoid conflicts
		let temp_dir = $"/tmp/borg-restore-(date now | format date '%Y%m%d-%H%M%S')"
		mkdir $temp_dir
		
		# Extract file to temp location
		^borgmatic extract --repository $repo --archive $selected_archive --destination $temp_dir --path $selected_file err>/dev/null
		let temp_file = $"($temp_dir)/($selected_file)"
		
		if ($temp_file | path exists) {
			# Show preview (first 50 lines)
			let file_lines = (cat $temp_file | lines)
			let preview_lines = ($file_lines | first 50)
			
			$preview_lines | each { |line| print $line }
			
			if (($file_lines | length) > 50) {
				print $"\n... (file truncated, showing first 50 of ($file_lines | length) lines)"
			}
			
			# Ask if user wants to restore
			print $"\nRestore this file? Current file will be backed up with .bak extension"
			let restore = (["yes", "no"] | input list "Restore file?")
			
			if ($restore == "yes") {
				# Backup current file if it exists
				if ($selected_file | path exists) {
					cp $selected_file $"($selected_file).bak"
					print $"Backed up current file to ($selected_file).bak"
				}
				
				# Create directory if it doesn't exist
				let parent_dir = ($selected_file | path dirname)
				if not ($parent_dir | path exists) {
					mkdir $parent_dir
				}
				
				# Restore file
				cp $temp_file $selected_file
				print $"Restored ($selected_file) from archive ($selected_archive)"
			} else {
				print "File not restored"
			}
			
			# Clean up temp directory
			rm -rf $temp_dir
		} else {
			print "Could not extract file for preview"
			rm -rf $temp_dir
		}
	} catch { |e|
		print $"Error during preview: ($e)"
	}
}
