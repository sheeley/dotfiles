#! /usr/bin/env -S uv run --script
# /// script
# dependencies = [
#     "textual",
#     "fuzzywuzzy",
#     "python-levenshtein",
# ]
# ///

"""
Interactive file search, preview, and restore tool for Borg backups via borgmatic.
"""

import argparse
import asyncio
import os
import shutil
import subprocess
import tempfile
from pathlib import Path
from typing import Dict, List, Tuple, Optional

from fuzzywuzzy import fuzz
from textual.app import App, ComposeResult
from textual.containers import Container, Horizontal, Vertical
from textual.widgets import (
    Footer,
    Header,
    Input,
    Label,
    ListItem,
    ListView,
    TextArea,
)
from textual.binding import Binding


class FileSearchApp(App):
    """Main application for searching and restoring files from Borg archives."""
    
    CSS = """
    .search-container {
        height: 5;
        margin: 1;
    }
    
    .main-container {
        height: 1fr;
    }
    
    .file-list {
        width: 1fr;
        border: solid $primary;
        margin-right: 1;
    }
    
    .archive-list {
        width: 1fr;
        border: solid $primary;
        margin-right: 1;
    }
    
    .preview-area {
        width: 2fr;
        border: solid $primary;
    }
    
    .status-bar {
        height: 3;
        background: $surface;
        margin: 1;
    }
    
    .activity {
        color: $warning;
        text-align: center;
        background: $surface;
        height: 3;
    }
    
    .fuzzy-search {
        margin: 1 0;
    }
    """
    
    BINDINGS = [
        Binding("ctrl+c", "quit", "Quit"),
        Binding("ctrl+q", "quit", "Quit"),
        Binding("escape", "back", "Back"),
        Binding("enter", "select", "Select/Restore"),
        Binding("ctrl+f", "focus_search", "Focus Search"),
    ]
    
    def __init__(self, search_term: str, all_repos: bool = False, content: bool = False):
        super().__init__()
        self.search_term = search_term
        self.repo = "" if all_repos else "local"
        self.content_search = content
        self.home_dir = os.path.expanduser("~")
        
        # State management
        self.found_files: List[Tuple[str, str]] = []
        self.filtered_files: List[Tuple[str, str]] = []
        self.selected_file_display = ""
        self.selected_file_full = ""
        self.archives_with_file: List[str] = []
        
        # Cache for various operations
        self.file_archives_cache: Dict[str, List[str]] = {}
        self.file_content_cache: Dict[Tuple[str, str], str] = {}  # (archive, file) -> content
        
        # Activity indicator state
        self.activity_tasks: Dict[str, asyncio.Task] = {}
        
        # Fuzzy search state
        self.fuzzy_filter = ""
        
        # Track if initial search is complete
        self.initial_search_complete = False
        self.search_task: Optional[asyncio.Task] = None
    
    def compose(self) -> ComposeResult:
        """Create the UI layout."""
        yield Header()
        
        with Container(classes="search-container"):
            yield Label(f"Searching for: {self.search_term}")
            yield Label(f"Search type: {'content' if self.content_search else 'filename'}")
            with Container(classes="fuzzy-search"):
                yield Label("Filter results:")
                yield Input(placeholder="Type to filter files...", id="fuzzy-input")
        
        with Horizontal(classes="main-container"):
            with Vertical(classes="file-list"):
                yield Label("Files", id="files-label")
                yield ListView(id="files-listview")
            
            with Vertical(classes="archive-list"):
                yield Label("Archives", id="archives-label")
                yield ListView(id="archives-listview")
            
            with Vertical(classes="preview-area"):
                yield Label("Preview", id="preview-label")
                yield TextArea("", read_only=True, id="preview-text")
        
        with Container(classes="status-bar"):
            yield Label("Ready", id="status")
        
        yield Footer()
    
    def on_mount(self) -> None:
        """Initialize the application by starting the search process immediately."""
        # Show immediate activity indicators
        self.show_initial_activity()
        
        # Start the search process in the background
        self.search_task = asyncio.create_task(self.search_files())
    
    def show_initial_activity(self) -> None:
        """Show activity indicators immediately when the app starts."""
        # Show activity in files list
        files_listview = self.query_one("#files-listview", ListView)
        files_listview.clear()
        files_listview.append(ListItem(Label("â ‹ Searching for files...", classes="activity")))
        
        # Show activity in archives list
        archives_listview = self.query_one("#archives-listview", ListView)
        archives_listview.clear()
        archives_listview.append(ListItem(Label("â ‹ Waiting for file search...", classes="activity")))
        
        # Show activity in status
        status = self.query_one("#status", Label)
        status.update("â ‹ Starting search...")
        status.add_class("activity")
        
        # Set preview to show what we're doing
        preview_text = self.query_one("#preview-text", TextArea)
        preview_label = self.query_one("#preview-label", Label)
        preview_label.update("Search Progress")
        preview_text.text = f"Searching for files matching: {self.search_term}\nRepository: {self.repo or 'all repositories'}\nSearch type: {'content' if self.content_search else 'filename'}\n\nThis may take a moment..."
        
        # Start animated activity indicators
        asyncio.create_task(self.start_activity_indicator("files-listview", f"Searching for files matching '{self.search_term}'"))
        asyncio.create_task(self.start_activity_indicator("archives-listview", "Waiting for file search to complete"))
        asyncio.create_task(self.start_activity_indicator("status", f"Searching for '{self.search_term}' in Borg archives"))
    
    async def start_activity_indicator(self, widget_id: str, base_message: str) -> None:
        """Start an animated activity indicator for a specific widget."""
        # Cancel existing task for this widget
        if widget_id in self.activity_tasks:
            self.activity_tasks[widget_id].cancel()
        
        self.activity_tasks[widget_id] = asyncio.create_task(
            self._animate_activity(widget_id, base_message)
        )
    
    async def stop_activity_indicator(self, widget_id: str) -> None:
        """Stop the activity indicator for a specific widget."""
        if widget_id in self.activity_tasks:
            self.activity_tasks[widget_id].cancel()
            del self.activity_tasks[widget_id]
    
    async def _animate_activity(self, widget_id: str, base_message: str) -> None:
        """Animate the activity indicator with rotating dots."""
        dots = ["â ‹", "â ™", "â ¹", "â ¸", "â ¼", "â ´", "â ¦", "â §", "â ‡", "â "]
        i = 0
        
        try:
            while True:
                message = f"{dots[i]} {base_message}"
                
                if widget_id == "files-listview":
                    listview = self.query_one("#files-listview", ListView)
                    listview.clear()
                    listview.append(ListItem(Label(message, classes="activity")))
                elif widget_id == "archives-listview":
                    listview = self.query_one("#archives-listview", ListView)
                    listview.clear()
                    listview.append(ListItem(Label(message, classes="activity")))
                elif widget_id == "preview-text":
                    preview = self.query_one("#preview-text", TextArea)
                    preview.text = message
                elif widget_id == "status":
                    status = self.query_one("#status", Label)
                    status.update(message)
                    status.add_class("activity")
                
                i = (i + 1) % len(dots)
                await asyncio.sleep(0.1)
        except asyncio.CancelledError:
            pass
    
    async def update_status(self, message: str, widget_id: str = "status") -> None:
        """Update status message and stop activity indicator."""
        await self.stop_activity_indicator(widget_id)
        
        if widget_id == "status":
            status = self.query_one("#status", Label)
            status.update(message)
            status.remove_class("activity")
    
    async def on_input_changed(self, event: Input.Changed) -> None:
        """Handle fuzzy search input changes."""
        if event.input.id == "fuzzy-input":
            self.fuzzy_filter = event.value
            await self.apply_fuzzy_filter()
    
    async def apply_fuzzy_filter(self) -> None:
        """Apply fuzzy search filter to the files list."""
        if not self.initial_search_complete:
            return
            
        if not self.fuzzy_filter.strip():
            self.filtered_files = self.found_files.copy()
        else:
            # Use fuzzy matching to filter files
            filtered = []
            for display_path, full_path in self.found_files:
                # Calculate fuzzy match score
                score = fuzz.partial_ratio(self.fuzzy_filter.lower(), display_path.lower())
                if score >= 60:  # Threshold for fuzzy matching
                    filtered.append((display_path, full_path))
            
            # Sort by fuzzy match score (best matches first)
            filtered.sort(key=lambda x: fuzz.partial_ratio(
                self.fuzzy_filter.lower(), x[0].lower()
            ), reverse=True)
            
            self.filtered_files = filtered
        
        await self.update_files_list()
        
        # Update status
        if self.fuzzy_filter.strip():
            await self.update_status(
                f"âœ… Showing {len(self.filtered_files)} of {len(self.found_files)} files (filtered)"
            )
        else:
            await self.update_status(f"âœ… Found {len(self.found_files)} unique files")
    
    async def search_files(self) -> None:
        """Search for files matching the search term."""
        try:
            # Run borgmatic search
            await self.start_activity_indicator("files-listview", f"Searching for files matching '{self.search_term}'...")
            await self.start_activity_indicator("status", f"Searching for files matching '{self.search_term}'...")
            
            cmd = [
                "borgmatic", "list", 
                "--repository", self.repo,
                "--find", self.search_term,
                "--short"
            ]
            
            result = subprocess.run(
                cmd, 
                capture_output=True, 
                text=True, 
                check=False
            )
            
            if result.returncode != 0:
                await self.update_status(f"âŒ Error searching: {result.stderr}", "files-listview")
                await self.update_status(f"âŒ Error searching: {result.stderr}")
                await self.stop_activity_indicator("archives-listview")
                return
            
            # Parse results and filter out verbose output
            all_files = []
            for line in result.stdout.splitlines():
                line = line.strip()
                if (line and 
                    "local:" not in line and 
                    "Listing archive" not in line and 
                    "Searching archives" not in line):
                    all_files.append(line)
            
            if not all_files:
                await self.update_status(f"âŒ No matches found for '{self.search_term}'", "files-listview")
                await self.update_status(f"âŒ No matches found for '{self.search_term}'")
                await self.stop_activity_indicator("archives-listview")
                return
            
            # Get unique files and replace home directory with ~
            unique_files = []
            seen = set()
            for file_path in all_files:
                if file_path not in seen:
                    seen.add(file_path)
                    display_path = self.format_display_path(file_path)
                    unique_files.append((display_path, file_path))
            
            unique_files.sort(key=lambda x: x[0])
            self.found_files = unique_files
            self.filtered_files = unique_files.copy()
            
            # Update files list
            await self.update_files_list()
            await self.update_status(f"âœ… Found {len(unique_files)} unique files", "files-listview")
            
            # Mark initial search as complete
            self.initial_search_complete = True
            
            # Update final status
            await self.update_status(f"âœ… Found {len(unique_files)} unique files")
            await self.stop_activity_indicator("archives-listview")
            
            # Clear archives list
            archives_listview = self.query_one("#archives-listview", ListView)
            archives_listview.clear()
            
            # Clear preview
            preview_text = self.query_one("#preview-text", TextArea)
            preview_label = self.query_one("#preview-label", Label)
            preview_label.update("Preview")
            preview_text.text = "Select a file to see its versions and preview content"
            
        except Exception as e:
            await self.update_status(f"âŒ Error during search: {str(e)}", "files-listview")
            await self.update_status(f"âŒ Error during search: {str(e)}")
            await self.stop_activity_indicator("archives-listview")
    
    def format_display_path(self, file_path: str) -> str:
        """Format file path for display, replacing home directory with ~."""
        if file_path.startswith(self.home_dir):
            return file_path.replace(self.home_dir, "~", 1)
        elif file_path.startswith("/Users/"):
            # Handle other user directories
            parts = file_path.split("/")
            if len(parts) >= 3:
                return "~" + "/" + "/".join(parts[3:])
        return file_path
    
    async def update_files_list(self) -> None:
        """Update the files list view."""
        await self.stop_activity_indicator("files-listview")
        files_listview = self.query_one("#files-listview", ListView)
        files_listview.clear()
        
        for display_path, _ in self.filtered_files:
            files_listview.append(ListItem(Label(display_path)))
    
    async def on_list_view_selected(self, event: ListView.Selected) -> None:
        """Handle selection in list views."""
        if event.list_view.id == "files-listview":
            await self.handle_file_selection(event.item.children[0].renderable)
        elif event.list_view.id == "archives-listview":
            await self.handle_archive_selection(event.item.children[0].renderable)
    
    async def on_list_view_highlighted(self, event: ListView.Highlighted) -> None:
        """Handle highlighting in list views."""
        if event.list_view.id == "files-listview" and event.item and self.initial_search_complete:
            # Immediately show archives when file is highlighted
            file_label = event.item.children[0].renderable
            if not file_label.startswith("â ‹"):  # Skip if it's an activity indicator
                await self.handle_file_highlight(file_label)
        elif event.list_view.id == "archives-listview" and event.item:
            # Update preview when archive is highlighted
            archive_name = event.item.children[0].renderable
            if not archive_name.startswith("â ‹") and not archive_name.startswith("No versions"):
                await self.show_preview(archive_name)
    
    async def handle_file_highlight(self, selected_label: str) -> None:
        """Handle file highlighting and immediately show archives."""
        # Skip if it's an activity indicator
        if selected_label.startswith("â ‹"):
            return
            
        self.selected_file_display = selected_label
        
        # Find the full path
        for display_path, full_path in self.filtered_files:
            if display_path == selected_label:
                self.selected_file_full = full_path
                break
        
        # Convert back to full path if needed
        if self.selected_file_display.startswith("~"):
            self.selected_file_full = self.selected_file_display.replace("~", self.home_dir, 1)
        
        # Show archives immediately from cache or search
        if self.selected_file_full in self.file_archives_cache:
            self.archives_with_file = self.file_archives_cache[self.selected_file_full]
            await self.update_archives_list()
            
            # Show preview of the first (most recent) archive automatically
            if self.archives_with_file:
                await self.show_preview(self.archives_with_file[0])
        else:
            # Search for archives containing this file
            await self.find_archives_with_file()
    
    async def handle_file_selection(self, selected_label: str) -> None:
        """Handle file selection (same as highlight for now)."""
        await self.handle_file_highlight(selected_label)
    
    async def find_archives_with_file(self) -> None:
        """Find all archives that contain the selected file."""
        await self.start_activity_indicator("archives-listview", f"Finding versions of {self.selected_file_display}...")
        await self.start_activity_indicator("status", f"Finding versions of {self.selected_file_display}...")
        
        try:
            # Get list of recent archives
            cmd = ["borgmatic", "list", "--repository", self.repo, "--short", "--last", "20"]
            result = subprocess.run(cmd, capture_output=True, text=True, check=False)
            
            if result.returncode != 0:
                await self.update_status(f"âŒ Error getting archives: {result.stderr}", "archives-listview")
                await self.update_status(f"âŒ Error getting archives: {result.stderr}")
                return
            
            archives = []
            for line in result.stdout.splitlines():
                line = line.strip()
                if line and "local:" not in line and "Listing archive" not in line:
                    archives.append(line)
            
            # Check which archives contain the file
            archives_with_file = []
            for i, archive in enumerate(archives):
                await self.start_activity_indicator(
                    "archives-listview", 
                    f"Checking archive {i+1}/{len(archives)}: {archive[:30]}..."
                )
                await self.start_activity_indicator(
                    "status", 
                    f"Checking archive {i+1}/{len(archives)}: {archive[:30]}..."
                )
                
                if await self.archive_contains_file(archive, self.selected_file_full):
                    archives_with_file.append(archive)
            
            archives_with_file.sort(reverse=True)  # Most recent first
            self.archives_with_file = archives_with_file
            
            # Cache the result
            self.file_archives_cache[self.selected_file_full] = archives_with_file
            
            if not archives_with_file:
                await self.update_status(f"âŒ No versions found for {self.selected_file_display}", "archives-listview")
                await self.update_status(f"âŒ No versions found for {self.selected_file_display}")
                archives_listview = self.query_one("#archives-listview", ListView)
                archives_listview.clear()
                archives_listview.append(ListItem(Label("No versions found")))
                return
            
            await self.update_archives_list()
            await self.update_status(
                f"âœ… Found {len(archives_with_file)} versions of {self.selected_file_display}"
            )
            
            # Show preview of the first (most recent) archive automatically
            if archives_with_file:
                await self.show_preview(archives_with_file[0])
            
        except Exception as e:
            await self.update_status(f"âŒ Error finding archives: {str(e)}", "archives-listview")
            await self.update_status(f"âŒ Error finding archives: {str(e)}")
    
    async def archive_contains_file(self, archive: str, file_path: str) -> bool:
        """Check if an archive contains the specified file."""
        try:
            cmd = [
                "borgmatic", "list",
                "--repository", self.repo,
                "--archive", archive,
                "--path", file_path,
                "--short"
            ]
            result = subprocess.run(cmd, capture_output=True, text=True, check=False)
            return result.returncode == 0 and result.stdout.strip()
        except:
            return False
    
    async def update_archives_list(self) -> None:
        """Update the archives list view."""
        await self.stop_activity_indicator("archives-listview")
        archives_listview = self.query_one("#archives-listview", ListView)
        archives_listview.clear()
        
        if not self.archives_with_file:
            archives_listview.append(ListItem(Label("No versions found")))
        else:
            for archive in self.archives_with_file:
                archives_listview.append(ListItem(Label(archive)))
    
    async def handle_archive_selection(self, selected_archive: str) -> None:
        """Handle archive selection and show preview."""
        # Skip if it's an activity indicator or no versions message
        if selected_archive.startswith("â ‹") or selected_archive.startswith("No versions"):
            return
        
        await self.show_preview(selected_archive)
    
    async def show_preview(self, archive: str) -> None:
        """Extract and show preview of the file from the selected archive."""
        # Check cache first
        cache_key = (archive, self.selected_file_full)
        if cache_key in self.file_content_cache:
            preview_text = self.query_one("#preview-text", TextArea)
            preview_label = self.query_one("#preview-label", Label)
            preview_label.update(f"Preview from {archive} (cached)")
            preview_text.text = self.file_content_cache[cache_key]
            return
        
        preview_text = self.query_one("#preview-text", TextArea)
        preview_label = self.query_one("#preview-label", Label)
        
        preview_label.update(f"Preview from {archive}")
        
        await self.start_activity_indicator("preview-text", f"Extracting preview from {archive[:30]}...")
        
        try:
            with tempfile.TemporaryDirectory(prefix="borg-preview-") as temp_dir:
                # Extract file
                cmd = [
                    "borgmatic", "extract",
                    "--repository", self.repo,
                    "--archive", archive,
                    "--destination", temp_dir,
                    "--path", self.selected_file_full
                ]
                
                result = subprocess.run(cmd, capture_output=True, text=True, check=False)
                
                if result.returncode == 0:
                    temp_file = Path(temp_dir) / self.selected_file_full.lstrip("/")
                    if temp_file.exists():
                        try:
                            with open(temp_file, 'r', encoding='utf-8') as f:
                                content = f.read()
                                # Limit preview to first 1000 lines
                                lines = content.splitlines()
                                if len(lines) > 1000:
                                    content = "\n".join(lines[:1000]) + f"\n\n... (truncated, showing first 1000 of {len(lines)} lines)"
                                
                                # Cache the content
                                self.file_content_cache[cache_key] = content
                                
                                await self.stop_activity_indicator("preview-text")
                                preview_text.text = content
                        except UnicodeDecodeError:
                            content = "ðŸ“ Binary file - cannot preview"
                            self.file_content_cache[cache_key] = content
                            await self.stop_activity_indicator("preview-text")
                            preview_text.text = content
                        except Exception as e:
                            content = f"âŒ Error reading file: {str(e)}"
                            await self.stop_activity_indicator("preview-text")
                            preview_text.text = content
                    else:
                        await self.stop_activity_indicator("preview-text")
                        preview_text.text = "âŒ File not found in archive"
                else:
                    await self.stop_activity_indicator("preview-text")
                    preview_text.text = f"âŒ Error extracting file: {result.stderr}"
                    
        except Exception as e:
            await self.stop_activity_indicator("preview-text")
            preview_text.text = f"âŒ Error during preview: {str(e)}"
    
    async def action_select(self) -> None:
        """Handle Enter key - restore the currently selected file."""
        archives_listview = self.query_one("#archives-listview", ListView)
        
        if archives_listview.highlighted_child:
            selected_archive = archives_listview.highlighted_child.children[0].renderable
            # Skip if it's an activity indicator or no versions message
            if not selected_archive.startswith("â ‹") and not selected_archive.startswith("No versions"):
                await self.restore_file(selected_archive)
    
    async def restore_file(self, archive: str) -> None:
        """Restore the selected file from the specified archive."""
        await self.start_activity_indicator("status", f"Restoring {self.selected_file_display} from {archive[:30]}...")
        
        try:
            with tempfile.TemporaryDirectory(prefix="borg-restore-") as temp_dir:
                # Extract file
                cmd = [
                    "borgmatic", "extract",
                    "--repository", self.repo,
                    "--archive", archive,
                    "--destination", temp_dir,
                    "--path", self.selected_file_full
                ]
                
                result = subprocess.run(cmd, capture_output=True, text=True, check=False)
                
                if result.returncode == 0:
                    temp_file = Path(temp_dir) / self.selected_file_full.lstrip("/")
                    if temp_file.exists():
                        # Backup current file if it exists
                        target_file = Path(self.selected_file_full)
                        if target_file.exists():
                            backup_file = f"{target_file}.bak"
                            shutil.copy2(target_file, backup_file)
                            await self.update_status(f"ðŸ’¾ Backed up current file to {backup_file}")
                            await asyncio.sleep(1)  # Brief pause to show backup message
                        
                        # Create directory if needed
                        target_file.parent.mkdir(parents=True, exist_ok=True)
                        
                        # Restore file
                        shutil.copy2(temp_file, target_file)
                        await self.update_status(f"âœ… Restored {self.selected_file_display} from {archive}")
                    else:
                        await self.update_status("âŒ File not found in extracted archive")
                else:
                    await self.update_status(f"âŒ Error extracting file: {result.stderr}")
                    
        except Exception as e:
            await self.update_status(f"âŒ Error during restoration: {str(e)}")
    
    async def action_focus_search(self) -> None:
        """Focus the fuzzy search input."""
        fuzzy_input = self.query_one("#fuzzy-input", Input)
        fuzzy_input.focus()
    
    async def action_back(self) -> None:
        """Handle Escape key - go back to previous view."""
        # Stop any ongoing activity
        for widget_id in list(self.activity_tasks.keys()):
            await self.stop_activity_indicator(widget_id)
        
        # Clear current selections and return to file list
        archives_listview = self.query_one("#archives-listview", ListView)
        archives_listview.clear()
        
        preview_text = self.query_one("#preview-text", TextArea)
        preview_text.text = ""
        
        preview_label = self.query_one("#preview-label", Label)
        preview_label.update("Preview")
        
        await self.update_status(f"âœ… Found {len(self.found_files)} unique files")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(description="Interactive file search and restore for Borg backups")
    parser.add_argument("search_term", help="Filename or content to search for")
    parser.add_argument("--all-repos", action="store_true", help="Search all repositories, not just local")
    parser.add_argument("--content", action="store_true", help="Search file contents instead of filenames")
    
    args = parser.parse_args()
    
    if args.content:
        print("Content search not yet implemented - searching filenames instead")
    
    app = FileSearchApp(args.search_term, args.all_repos, args.content)
    app.run()


if __name__ == "__main__":
    main()
